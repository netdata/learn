# Imports
import argparse
import copy
import glob
import itertools
import os
import pathlib
import re
import shutil
import errno
import git
import json
from mergedeep import merge
from collections import OrderedDict
from operator import getitem
import ast


'''
TODO: Automate the exporting references (tricky part, annotate which are supported by the cloud)
TODO: Automate the notification references (tricky part, annotate which are supported by the cloud)
'''

def unpackDictionaryStringToDictionary(stringInput):
    return(ast.literal_eval(stringInput))

def generate(index, outputFile):
	introOutputText = f'''---
title: "Integrations"
sidebar_label: "Integrations"
custom_edit_url: "null"
learn_status: "Published"
learn_topic_type: "Getting started"
learn_rel_path: "Getting started"
learn_docs_purpose: "Present all the Netdata integrations"
learn_doc_type: "AUTOGENERATED"
---

Netdata Solution support many integrations, this document will guide you through all the integrations. We categorize
our integration by their purpose: *Notification methods*, *Supported Collectors* and *Exporting options*

:::info

The following lists contain the links to the reference pages of each component. You can visit those pages to see their
capabilities.

:::


'''

	collectorsOutputText = '''
## Supported Collectors

'''

	notificationsOutputText = f'''
## Supported Notifications methods

'''

	exportersOutputText = f'''
## Supported options to export data

'''

	collectorsBucket = dict()
	notificationsBucket = dict()
	exportersBucket = dict()
	#print(json.dumps(collectorsDic, indent=4))
	for key in index.keys():
		refPrefix = ''
		if len(index[key]["metadata"]["learn_rel_path"].split("References/"))>1:
			refPrefix = index[key]["metadata"]["learn_rel_path"].lower().split("references/")[1]
			if refPrefix.__contains__("collectors"):
				collectorCategory = index[key]["metadata"]["learn_rel_path"].lower().split("references/collectors references/")[1]
				if collectorCategory in collectorsBucket.keys():
					collectorsBucket[collectorCategory] = merge(collectorsBucket[collectorCategory], {key: index[key]})
				else:
					collectorsBucket[collectorCategory] = {key: index[key]}
			elif refPrefix.__contains__("exporting"):
				exportersBucket[index[key]["metadata"]["sidebar_label"]] = index[key]
			elif refPrefix.__contains__("notification"):
				notificationsBucket[index[key]["metadata"]["sidebar_label"]] = index[key]
			else:
				pass
	orderedCollectorsBucket = OrderedDict(sorted(collectorsBucket.items()))
	orderedeExportersBucket = OrderedDict(sorted(exportersBucket.items()))
	orderedNotifactionsBucket = OrderedDict(sorted(notificationsBucket.items()))
	#print(json.dumps(orderedCollectorsBucket, indent = 4) )
	#print("*********************************")
	#print(json.dumps(orderedeExportersBucket, indent = 4) )
	#print("*********************************")
	#print(json.dumps(orderedNotifactionsBucket, indent = 4) )

	headings_3 = set()
	headings_4 = set()


	for key in orderedCollectorsBucket:
		#print(key)
		temp = key.split("/")
		if temp[0] not in headings_3:
			headings_3.add(temp[0])
			collectorsOutputText += ("### "+ temp[0]+"\n")
		if len(temp) >1:
			if temp[1] not in headings_4:
				headings_4.add(temp[1])
				collectorsOutputText += ("#### "+ temp[1]+"\n")
		collectorsOutputText += ("\n")
		for key1 in orderedCollectorsBucket[key]:
			collectorsOutputText += "- [{}]({})\n".format(orderedCollectorsBucket[key][key1]["metadata"]["sidebar_label"], orderedCollectorsBucket[key][key1]["metadata"]["custom_edit_url"] )
		collectorsOutputText += ("\n")

	collectorsOutputText += ("\n")

	for key in orderedNotifactionsBucket:
		partOfCloud = unpackDictionaryStringToDictionary(orderedNotifactionsBucket[key]["metadata"]["learn_autogeneration_metadata"])["part_of_cloud"]
		if partOfCloud == False:
			notificationsOutputText += ("- [{}]({}) *\n".format(key,orderedNotifactionsBucket[key]["metadata"]["custom_edit_url"]))
		else:
			notificationsOutputText += ("- [{}]({}) \n".format(key,orderedNotifactionsBucket[key]["metadata"]["custom_edit_url"]))

	notificationsOutputText += "\n"

	notificationsOutputText += """

:::info

`*` These Notification options are available only in the Agent.

:::

"""

	for key in orderedeExportersBucket:
		partOfCloud = unpackDictionaryStringToDictionary(orderedeExportersBucket[key]["metadata"]["learn_autogeneration_metadata"])["part_of_cloud"]
		if partOfCloud == False:
			exportersOutputText += ("- [{}]({}) *\n".format(key,orderedeExportersBucket[key]["metadata"]["custom_edit_url"]))
		else:
			exportersOutputText += ("- [{}]({})\n".format(key,orderedeExportersBucket[key]["metadata"]["custom_edit_url"]))

	exportersOutputText += "\n"
	exportersOutputText += """

:::info

`*` These exporting options are available only in the Agent.

:::
	
"""

	OutputText = introOutputText+collectorsOutputText+notificationsOutputText+exportersOutputText
	with open(outputFile, "w+") as fd:
		fd.write(OutputText)

	#print(json.dumps(orderedCollectorsBucket, indent=4))

