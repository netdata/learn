"""
This is the script that gathers markdown files from all of Netdata's repos in this repo

Stages of this ingest script:

    Stage_1: Ingest every available markdown from the defaultRepos

    Stage_2: We create three buckets:
                1. all_markdown_files: all the markdown files in defaultRepos
                2. markdown_files_with_metadata: all the markdown files that have hidden metadata fields
                3. toPublish: markdown files that must be included in the learn 
                    (metadata_key_value: "learn_status": "Published") 

    Stage_3: 
        1. Move the toPublish markdown files under the DOCS_PREFIX folder based on their metadata (they decide where, 
            they live)
        2. Generate autogenerated pages

    Stage_4: Sanitization
                1. Make the hidden metadata fields actual readable metadata for docusaurus
                2. 
                
    Stage_5: Convert GH links to version specific links
"""

# Imports
import argparse
import ast
import errno
import glob
import os
import re
import shutil
import urllib.parse
from pathlib import Path

import git
import numpy as np
import pandas as pd

import autogenerateRedirects as genRedirects

DRY_RUN = False
DEBUG = False
DOCS_PREFIX = "will be added by arguments"

rest_files_dictionary = {}
rest_files_with_metadata_dictionary = {}
to_publish = {}
all_markdown_files = []
UNCORRELATED_LINK_COUNTER = 0
# Dict mapping repo name to dict of broken URLs -> set of source files
UNCORRELATED_URLS_BY_REPO = {}
# Dict mapping repo name to dict of (url, header) -> set of source files
BROKEN_HEADER_LINKS_BY_REPO = {}
FAIL_ON_REPOS = set()  # Set of repo names to fail on if broken links found
FAIL_ON_ALL_BROKEN_LINKS = False  # If True, fail on any broken link regardless of repo
# Temporarily until we release (change it (the default) to /docs
# version_prefix = "nightly"  # We use this as the version prefix in the link strategy
TEMP_FOLDER = "ingest-temp-folder"
default_repos = {
    "netdata":
        {
            "owner": "netdata",
            "branch": "master",
            "HEAD": "master",
        },
    "netdata-cloud-onprem":
        {
            "owner": "netdata",
            "branch": "master",
            "HEAD": "master",
        },
    ".github":
        {
            "owner": "netdata",
            "branch": "main",
            "HEAD": "main",
        },
    "agent-service-discovery":
        {
            "owner": "netdata",
            "branch": "master",
            "HEAD": "master",
        },
    "netdata-grafana-datasource-plugin":
        {
            "owner": "netdata",
            "branch": "master",
            "HEAD": "master",
        },
    "helmchart":
        {
            "owner": "netdata",
            "branch": "master",
            "HEAD": "master",
        }
}


def clean_and_lower_string(string):
    return re.sub(r'(-)+', '-', string.lower().replace(",", "-").replace(" ", "-").replace("//", "/"))


def extract_headers_from_file(file_path):
    """
    Extract all headers from a markdown file and return them as a set of anchor IDs.
    Headers are converted to anchor format: lowercase, spaces to hyphens, special chars removed.
    """
    headers = set()
    try:
        content = Path(file_path).read_text()
        # Match markdown headers (# Header, ## Header, etc.)
        header_pattern = r'^#{1,6}\s+(.+)$'
        for match in re.finditer(header_pattern, content, re.MULTILINE):
            header_text = match.group(1).strip()
            # Convert header to anchor ID (similar to how markdown processors do it)
            # Remove inline code backticks, bold/italic markers
            anchor = re.sub(r'[`*_]', '', header_text)
            # Remove HTML tags
            anchor = re.sub(r'<[^>]+>', '', anchor)
            # Convert to lowercase, replace spaces with hyphens
            anchor = anchor.lower().replace(' ', '-')
            # Remove special characters except hyphens
            anchor = re.sub(r'[^a-z0-9-]', '', anchor)
            # Remove multiple consecutive hyphens
            anchor = re.sub(r'-+', '-', anchor)
            # Remove leading/trailing hyphens
            anchor = anchor.strip('-')
            if anchor:
                headers.add(anchor)
    except Exception as e:
        pass
    return headers


def validate_header_in_file(file_path, header):
    """
    Check if a header/anchor exists in the target file.
    Returns True if the header exists or if header is empty, False otherwise.
    """
    if not header:
        return True
    headers = extract_headers_from_file(file_path)
    # Also check the raw header (some anchors are preserved as-is)
    return header.lower() in headers or header in headers


def extract_repo_from_github_url(url):
    """
    Extract the repository name from a GitHub URL.
    
    Example:
        https://github.com/netdata/netdata/blob/master/src/file.md -> netdata
        https://github.com/netdata/helmchart/blob/master/README.md -> helmchart
    """
    if not url.startswith("https://github.com/netdata/"):
        return "unknown"
    
    # URL format: https://github.com/netdata/<repo>/...
    parts = url.replace("https://github.com/netdata/", "").split("/")
    if parts:
        return parts[0]
    return "unknown"


def extract_repo_from_local_path(path):
    """
    Extract the repository name from a local path in the temp folder.
    
    Example:
        ingest-temp-folder/netdata/src/file.md -> netdata
        docs/something/file.mdx -> unknown (not from temp folder)
    """
    if path.startswith(TEMP_FOLDER + "/"):
        parts = path.replace(TEMP_FOLDER + "/", "").split("/")
        if parts:
            return parts[0]
    return "unknown"


def add_broken_url(repo, url, source_file):
    """Add a broken URL to the tracking dictionary, categorized by repo."""
    global UNCORRELATED_URLS_BY_REPO
    if repo not in UNCORRELATED_URLS_BY_REPO:
        UNCORRELATED_URLS_BY_REPO[repo] = {}
    if url not in UNCORRELATED_URLS_BY_REPO[repo]:
        UNCORRELATED_URLS_BY_REPO[repo][url] = set()
    UNCORRELATED_URLS_BY_REPO[repo][url].add(source_file)


def add_broken_header(repo, full_link, header, source_file):
    """Add a broken header link to the tracking dictionary, categorized by repo."""
    global BROKEN_HEADER_LINKS_BY_REPO
    if repo not in BROKEN_HEADER_LINKS_BY_REPO:
        BROKEN_HEADER_LINKS_BY_REPO[repo] = {}
    key = (full_link, header)
    if key not in BROKEN_HEADER_LINKS_BY_REPO[repo]:
        BROKEN_HEADER_LINKS_BY_REPO[repo][key] = set()
    BROKEN_HEADER_LINKS_BY_REPO[repo][key].add(source_file)


def github_url_to_local_path(url):
    """
    Convert a GitHub URL to a local path in the temp folder.
    Returns the local path if it can be constructed, None otherwise.
    
    Example:
        https://github.com/netdata/netdata/blob/master/src/go/pkg/prometheus/selector/README.md
        -> ingest-temp-folder/netdata/src/go/pkg/prometheus/selector/README.md
    """
    if not url.startswith("https://github.com/netdata"):
        return None
    
    # Convert URL to local path
    local_path = url.replace("https://github.com/netdata", TEMP_FOLDER)
    local_path = local_path.replace("edit/", "blob/", 1)
    local_path = local_path.replace("blob/master/", "")
    local_path = local_path.replace("blob/main/", "")
    
    return local_path


def file_exists_in_repos(url):
    """
    Check if a GitHub URL points to a file that exists in the cloned repos.
    Returns True if the file exists, False otherwise.
    """
    local_path = github_url_to_local_path(url)
    if local_path is None:
        return False
    return Path(local_path).exists()


def convert_parenthetical_slash(segment: str) -> str:
    """
    Convert occurrences like "(ABC/XYZ)" into "ABC-XYZ" inside a string.
    Only converts simple parenthetical groups containing a single slash.
    """
    if not segment:
        return segment

    # Replace occurrences of (A/B) or (A/B/C) with A-B or A-B-C respectively
    def repl(m):
        inner = m.group(1)
        parts = inner.split('/')
        return '-'.join(parts)

    return re.sub(r"\(([^()]+?/[^()]+?)\)", repl, segment)


def populate_integrations(markdownFiles):
    """
    if a symlink, read that, if not, look inside integrations folder.
    """

    print("### Populating map from Integration metadata rows ###\n")

    metadata_dictionary = {}
    ignore_dup = []

    # Read the map file, to replace the placeholder for the dynamic part
    map_file = pd.read_csv("map.csv")

    collectors_entries = pd.DataFrame()
    exporting_entries = pd.DataFrame()
    alerting_agent_entries = pd.DataFrame()
    alerting_cloud_entries = pd.DataFrame()
    authentication_entries = pd.DataFrame()
    logs_entries = pd.DataFrame()

    readmes_first = []
    others_last = []
    for file in markdownFiles:
        if "README.md" in file:
            readmes_first.append(file)
        else:
            others_last.append(file)

    markdownFiles = readmes_first + others_last

    for file in markdownFiles:
        path = file.split("integrations")[0].replace("README.md", "")

        whole_file = Path(file).read_text()

        if whole_file not in ignore_dup and "DO NOT EDIT THIS FILE DIRECTLY" in whole_file:

            meta = whole_file.split(
                "endmeta-->")[0].replace("<!--startmeta", "---") + "---"

            metadata_dictionary = read_metadata(meta)

            if os.path.islink(file):
                ignore_dup.append(whole_file)
                # If it is a manual symlink, meaning a README symlink but the folder has more than one integration, thus their custom_edit_urls are unique. 1:1 integrations have the README link as custom_edit_url
                if not file.replace("ingest-temp-folder/", "").split('/', 1)[1] in metadata_dictionary[
                    'custom_edit_url']:
                    proper_edit_url = file.replace(
                        "ingest-temp-folder/", "")

                    proper_edit_url = "https://github.com/netdata/" + \
                                      proper_edit_url.split(
                                          '/', 1)[0] + "/edit/master/" + proper_edit_url.split('/', 1)[1]
                    metadata_dictionary['custom_edit_url'] = proper_edit_url

                    # print("path:", file)
                    # print(metadata_dictionary)

            metadf = pd.DataFrame([metadata_dictionary])
            # print(file)
            if "collector" in path:
                collectors_entries = pd.concat(
                    [collectors_entries, metadf])
                # print(collectors_entries)
                # quit()
            elif "exporting" in path:
                exporting_entries = pd.concat([exporting_entries, metadf])
                # print(exporting_entries)
            elif "cloud-authentication" in file:
                authentication_entries = pd.concat([authentication_entries, metadf])
            # here we need a different check, as the path variable gets messed up
            elif "cloud-notifications" in file:

                # print("in")
                alerting_cloud_entries = pd.concat(
                    [alerting_cloud_entries, metadf])
            elif "logs" in file:
                # Custom location for Logs integrations, as they normally have a pretty big README that we add as a reference, as a child to the integration's folder.
                metadf['learn_rel_path'] = metadf['learn_rel_path'] + "/" + metadf['sidebar_label']

                logs_entries = pd.concat([logs_entries, metadf])
            else:
                alerting_agent_entries = pd.concat(
                    [alerting_agent_entries, metadf])

    # print("Collectors\n", collectors_entries, "Agent alerts\n", alerting_agent, "Cloud alerts\n",  alerting_cloud, "Exporting",  exporting_entries)

    replace_index = map_file.loc[map_file['custom_edit_url']
                                 == "authentication_integrations"].index
    # print(replace_index[0])
    upper = map_file.iloc[:replace_index[0]]
    lower = map_file.iloc[replace_index[0] + 1:]

    map_file = pd.concat([upper, authentication_entries.sort_values(
        by=['learn_rel_path', 'sidebar_label'], key=lambda col: col.str.lower()), lower], ignore_index=True)

    replace_index = map_file.loc[map_file['custom_edit_url']
                                 == "collectors_integrations"].index
    # print(replace_index[0])
    upper = map_file.iloc[:replace_index[0]]
    lower = map_file.iloc[replace_index[0] + 1:]

    map_file = pd.concat([upper, collectors_entries.sort_values(
        by=['learn_rel_path', 'sidebar_label'], key=lambda col: col.str.lower()), lower], ignore_index=True)

    replace_index = map_file.loc[map_file['custom_edit_url']
                                 == "agent_notifications_integrations"].index
    # print(replace_index[0])
    upper = map_file.iloc[:replace_index[0]]
    lower = map_file.iloc[replace_index[0] + 1:]

    map_file = pd.concat([upper, alerting_agent_entries.sort_values(
        by=['learn_rel_path', 'sidebar_label'], key=lambda col: col.str.lower()), lower], ignore_index=True)

    replace_index = map_file.loc[map_file['custom_edit_url']
                                 == "cloud_notifications_integrations"].index
    upper = map_file.iloc[:replace_index[0]]
    lower = map_file.iloc[replace_index[0] + 1:]

    map_file = pd.concat([upper, alerting_cloud_entries.sort_values(
        by=['learn_rel_path', 'sidebar_label'], key=lambda col: col.str.lower()), lower], ignore_index=True)

    replace_index = map_file.loc[map_file['custom_edit_url']
                                 == "exporters_integrations"].index
    # print(replace_index[0])
    upper = map_file.iloc[:replace_index[0]]
    lower = map_file.iloc[replace_index[0] + 1:]

    map_file = pd.concat([upper, exporting_entries.sort_values(
        by=['learn_rel_path', 'sidebar_label'], key=lambda col: col.str.lower()), lower], ignore_index=True)

    replace_index = map_file.loc[map_file['custom_edit_url']
                                 == "logs_integrations"].index
    upper = map_file.iloc[:replace_index[0]]
    lower = map_file.iloc[replace_index[0] + 1:]

    map_file = pd.concat([upper, logs_entries.sort_values(
        by=['learn_rel_path', 'sidebar_label'], key=lambda col: col.str.lower()), lower], ignore_index=True)

    map_file.to_csv("ingest/generated_map.tsv", sep='\t', index=False)

    # quit()
    return map_file


def unsafe_cleanup_folders(folder_to_delete):
    """Cleanup every file in the specified folderToDelete."""
    print("Try to clean up the folder: ", folder_to_delete)
    try:
        shutil.rmtree(folder_to_delete)
        print("Done")
    except Exception as e:
        print("Couldn't delete the folder due to the exception: \n", e)


def produce_gh_view_link_for_repo(repo, file_path):
    """
    This function return the GitHub link (view link) of a repo e.g <owner>/<repo>
    Limitation it produces only  the master, main links only for the netdata org
    """
    if repo == ".github":
        return f"https://github.com/netdata/{repo}/blob/main/{file_path}"
    else:
        return f"https://github.com/netdata/{repo}/blob/master/{file_path}"


def produce_gh_edit_link_for_repo(repo, file_path):
    """
    This function return the GitHub link (view link) of a repo e.g <owner>/<repo>
    Limitation it produces only  the master, main links only for the netdata org
    """
    if repo == ".github":
        return f"https://github.com/netdata/{repo}/edit/main/{file_path}"
    else:
        return "https://github.com/netdata/{repo}/edit/master/{file_path}"


def safe_cleanup_learn_folders(folder_to_delete):
    """
    Cleanup every file in the specified folderToDelete, that doesn't have the `part_of_learn: True`
    metadata in its metadata. It also prints a list of the files that don't have this kind of
    """
    deleted_files = []
    md_files = fetch_markdown_from_repo(folder_to_delete)
    print(
        f"Files in the {folder_to_delete} folder #{len(md_files)} which are about to be deleted")
    for md in md_files:

        metadata = read_metadata(Path(md).read_text().split("-->")[0])
        try:
            if "part_of_learn" in metadata.keys():
                # Reductant condition to emphasize what we are looking for when we clean up learn files
                if metadata["part_of_learn"] == "True":
                    pass
            else:
                deleted_files.append(md)
                os.remove(md)
        except Exception as e:
            print(f"Couldn't delete the {md} file reason: {e}")
    print(
        f"Cleaned up #{len(deleted_files)} files under {folder_to_delete} folder")


def verify_string_is_dictionary(string_input):
    """
    function to verify that a string input is of dictionary type
    """
    try:
        if isinstance(ast.literal_eval(string_input), dict):
            return True
        else:
            return False
    except:
        return False


def unpack_dictionary_string_to_dictionary(string_input):
    return ast.literal_eval(string_input)


def copy_doc(src, dest):
    """
    Copy a file
    """
    # Get the path
    try:
        shutil.copy(src, dest)
    except IOError as e:
        # ENOENT(2): file does not exist, raised also on missing dest parent dir
        if e.errno != errno.ENOENT:
            raise
        # try creating parent directories
        os.makedirs(os.path.dirname(dest))
        shutil.copy(src, dest)


def clone_repo(owner, repo, branch, depth, prefix_folder, gh_token=None):
    """
    Clone a repo using HTTPS+PAT (if provided) or SSH.
    Removes secrets from the remote after cloning.
    """
    try:
        output_folder = os.path.join(prefix_folder, repo)
        if gh_token:
            enc = urllib.parse.quote(gh_token, safe="")
            url = f"https://x-access-token:{enc}@github.com/{owner}/{repo}.git"
        else:
            url = f"git@github.com:{owner}/{repo}.git"

        git.Git().clone(url, output_folder, depth=depth, branch=branch)

        # Immediately scrub the remote to a non-secret URL
        clean_url = f"https://github.com/{owner}/{repo}.git"
        git.Git(output_folder).remote('set-url', 'origin', clean_url)

        return f"Cloned the {branch} branch from {repo} repo (owner: {owner})"
    except Exception as e:
        return (f"Couldn't clone the {branch} branch from {repo} repo (owner: {owner}) \n"
                f" Exception {e} raised")


def create_mdx_path_from_metadata(metadata):
    """
    Create a path from the documents metadata
    REQUIRED KEYS in the metadata input:
        [sidebar_label, learn_rel_path]
    In the returned (final) path we sanitize "/", "//" , "-", "," with one dash
    """
    final_file = ' '.join((metadata["sidebar_label"]
                           .replace("'", " ")
                           .replace(":", " ")
                           .replace("/", " ")
                           .replace(")", " ")
                           .replace(",", " ")
                           .replace("(", " ")
                           .replace("`", " ")).split())

    if "Collecting Metrics" in metadata['learn_rel_path'] \
            and metadata['learn_rel_path'].split("/")[-1] != "Collecting Metrics" and 'External-plugins' not in \
            metadata['learn_rel_path']:
        last_folder = metadata['learn_rel_path'].split("Collecting Metrics", 1)[1]
        last_folder = "collecting-metrics" + last_folder

        # non-integration folders inside collecting metrics
        if "Metrics Centralization Points" in metadata['learn_rel_path']:
            slug = "/{}/{}".format(metadata["learn_rel_path"],
                                   final_file.replace(" ", "-")).lower().replace(" ", "-").replace("//", "/")
            if slug.rsplit("/")[-1] == slug.rsplit("/")[-2]:
                return ["{}/{}/{}.mdx".format(DOCS_PREFIX,
                                              metadata["learn_rel_path"]
                                              .split("Collecting Metrics")[0].lower().replace(" ", "-") + last_folder,
                                              final_file).replace("//", "/"),
                        "/{}/{}".format(metadata["learn_rel_path"],
                                        final_file.replace(" ", "-")).lower().replace(" ", "-").replace("//",
                                                                                                        "/").rsplit("/",
                                                                                                                    1)[
                            0]]
            else:
                return ["{}/{}/{}.mdx".format(DOCS_PREFIX,
                                              metadata["learn_rel_path"]
                                              .split("Collecting Metrics")[0].lower().replace(" ", "-") + last_folder,
                                              final_file).replace("//", "/"),
                        "/{}/{}".format(metadata["learn_rel_path"],
                                        final_file.replace(" ", "-")).lower().replace(" ", "-").replace("//", "/")]

        # print(last_folder)
        # exit()
        # If the file is inside the monitor-anything category,
        # meaning that it will try to render the sidebar category label to whatever the folder has,
        # return an array of two things; [the final path, the proper slug].
        # We use the slug to avoid having %20 (replacing spaces) in the link of the file.
        return ["{}/{}/{}.mdx".format(DOCS_PREFIX,
                                      metadata["learn_rel_path"]
                                      .split("Collecting Metrics")[0].lower().replace(" ", "-") + last_folder,
                                      final_file.replace(" ", "-")).replace("//", "/"),
                "/{}/{}".format(metadata["learn_rel_path"],
                                final_file.replace(" ", "-")).lower().replace(" ", "-").replace("//", "/")]

    else:
        return ("{}/{}/{}.mdx".format(DOCS_PREFIX,
                                      metadata["learn_rel_path"],
                                      final_file.replace(" ", "-")).lower().replace(" ", "-").replace("//", "/"))


def fetch_markdown_from_repo(output_folder):
    return glob.glob(
        output_folder + '/**/*.md*', recursive=True) + glob.glob(output_folder + '/.**/*.md*', recursive=True)


def insert_and_read_hidden_metadata_from_doc(path_to_file, dictionary):
    """
    Taking a path of a file as input
    Identify the area with pattern " <!-- ...multiline string -->" and  converts them
    to a dictionary of key:value pairs
    """
    # TODO work here, predict yaml file from path, should be easy, if readme try os.exists for meta yaml, if inside integrations folder, try one out.

    # TODO unique in custom edit url might need custom editurl + sidebar_label so it can be reproduced here.
    repo, path = path_to_file.replace("ingest-temp-folder/", "").split('/', 1)

    if repo == ".github":
        key = "https://github.com/netdata/" + repo + "/edit/main" + "/" + path
    else:
        key = "https://github.com/netdata/" + repo + "/edit/master" + "/" + path

    output = ""
    for field in dictionary.loc[dictionary['custom_edit_url'] == key]:
        try:
            val = dictionary.loc[dictionary['custom_edit_url']
                                 == key][field].values[0]

            # print((not val == np.nan),  val != val, val)
            val = str(val)

            if (not val == np.nan) and val != "nan":

                if field == "learn_rel_path":
                    if val == "root":
                        # print("ROOT")
                        val = "/"

                    if "Collecting Metrics" in val or "Collecting Metrics" in val:
                        output += "toc_max_heading_level: 4\n"

                if field == "sidebar_position":
                    output += "{0}: \"{1}\"\n".format(field,
                                                      val.replace("\"", ""))
                else:
                    output += "{0}: \"{1}\"\n".format(field,
                                                      val.replace("\"", ""))

        except Exception as e:
            pass

    if len(output) > 0:
        output = "<!--\n" + output + "-->\n"

        whole_file = Path(path_to_file).read_text()

        if whole_file.startswith("<!--"):
            body = whole_file.split("-->", 1)[1]
        else:
            body = whole_file

        Path(path_to_file).write_text(output + body)

        # print(path_to_file, output)
        metadata_dictionary = {}
        with open(path_to_file, "r+") as fd:
            raw_text = "".join(fd.readlines())
            pattern = r"((^<!--|^---)\n)((.|\n)*?)(\n(-->|---))"
            match_group = re.search(pattern, raw_text)
            # print(match_group)
            if match_group:
                raw_metadata = match_group[3]
                list_metadata = raw_metadata.split("\n")
                while list_metadata:
                    line = list_metadata.pop(0)
                    split_in_keywords = line.split(": ", 1)
                    key = split_in_keywords[0]
                    value = split_in_keywords[1]
                    if verify_string_is_dictionary(value):
                        value = unpack_dictionary_string_to_dictionary(value)
                    # If it's a multiline string
                    while list_metadata and len(list_metadata[0].split(": ", 1)) <= 1:
                        line = list_metadata.pop(0)
                        value = value + line.lstrip(' ')
                    value = value.strip("\"")
                    metadata_dictionary[key] = value.lstrip('>-')
        # print("\n\n")
        return metadata_dictionary
    else:
        return []


def update_metadata_of_file(path_to_file, dictionary):
    """
    Taking a path of a file as input
    Identify the area with pattern
    "<!-- ...multiline string -->"
    and converts them to a dictionary
    of key:value pairs
    """

    output = ""

    for field in dictionary:
        val = str(dictionary[field]).replace("\"", "")
        output += f"{field}: \"{val}\"\n"
    if len(output) > 0:
        output = "<!--\n" + output + "-->"

    whole_file = Path(path_to_file).read_text()

    if whole_file.startswith("<!--"):
        body = whole_file.split("-->", 1)[1]
    else:
        body = whole_file

    Path(path_to_file).write_text(output + body)


def read_metadata(meta):
    metadata_dictionary = {}
    pattern = r"((<!--|---)\n)((.|\n)*?)(\n(-->|---))"
    match_group = re.search(pattern, meta)

    # If metadata is found
    if match_group:
        raw_metadata = match_group[3]
        list_metadata = raw_metadata.split("\n")
        # Split the key: value pairs
        while list_metadata:
            line = list_metadata.pop(0)
            split_in_keywords = line.split(": ", 1)
            key = split_in_keywords[0]
            value = split_in_keywords[1]
            if verify_string_is_dictionary(value):
                value = unpack_dictionary_string_to_dictionary(
                    value)
            # If it's a multiline string
            while list_metadata and len(list_metadata[0].split(": ", 1)) <= 1:
                line = list_metadata.pop(0)
                value = value + line.lstrip(' ')
            value = value.strip("\"")
            metadata_dictionary[key] = value.lstrip('>-')

    return metadata_dictionary


def sanitize_page(path):
    """
    Converts the
        "<!--" -> "---"
        "-->" -> "---"
    It converts only the first occurrences of these patterns
    Side effect:
        If the document doesn't have purposeful metadata but it contains this pattern in it's body this function replace
        these patterns
    """

    body = Path(path).read_text()

    # Replace the metadata with comments
    body = body.replace("<!--", "---", 1)
    body = body.replace("-->", "---", 1)

    # Custom elements we don't want on GitHub
    body = body.replace("<!--unhideme", "")
    body = body.replace("unhideme-->", "")

    # MDX 3 compatibility replacements
    body = body.replace("<details><summary>", "<details>\n<summary>")
    body = body.replace("<details open><summary>", "<details open>\n<summary>")
    body = body.replace("${", r"$\{")
    body = body.replace("<=", r"\<=")
    body = body.replace("%<", r"%\<")
    body = body.replace("{{", r"\{\{")
    body = body.replace("style=\\{\\{", "style={{")
    body = body.replace("<->", r"\<->")
    body = body.replace("{attribute_name}", r"\{attribute_name}")
    body = body.replace("{attribute_unit}", r"\{attribute_unit}")

    # <url> into [url](url)
    body = re.sub(r'<(https://[^>]+)>', r'[\1](\1)', body)
    body = re.sub(r'<(http://[^>]+)>', r'[\1](\1)', body)
    body = re.sub(r'<([\w\.-]+@[\w\.-]+\.\w+)>', r'[\1](mailto:\1)', body)

    match_group = re.search(r'meta_yaml: "(.*)"', body)
    if match_group:
        # If the file has a meta_yaml field, then it is an integration, and we need to put the value into custom_edit_url too
        body = re.sub(r"meta_yaml:.*\n",
                      "",
                      re.sub(r'custom_edit_url:.*',
                             f"custom_edit_url: \"{match_group[1]}\"",
                             body))

    # The list with the lines that will be written in the file
    output = []

    # For each line of the file I read
    for line in body.splitlines():
        # If the line isn't an H1 title, and it isn't an analytics pixel, append it to the output list
        if not line.startswith("[![analytics]"):
            output.append(line + "\n")
    output = "".join(output)
    # Try to remove excess newlines from the start of the document
    output = re.sub(r'---(\n\s*\n)', '---\n\n', output)
    # Try to add a newline to the start of a document that has no newline
    if not re.match(r'---(\n\s*\n)', output):
        # print(path, "not matching")
        output = output.replace("---\n", "---\n\n", 2)
        # revert first line
        output = output.replace("---\n\n", "---\n", 1)

    # Open the file for overwriting, we are going to write the output list in the file
    Path(path).write_text(output)


def add_new_learn_path_key_to_dict(input_dict, docs_prefix, docs_path_learn, temp_folder):
    """
    This function takes as an argument our dictionary of the Ingest process and creates a new dictionary with key-value
    pairs of type Source file -> Target file (learn_absolute path)
    """
    output_dictionary = dict()
    for element in input_dict:
        repo = input_dict[element]["ingestedRepo"]
        file_path = element.replace(temp_folder + "/" + repo + "/", "")

        source_link = produce_gh_view_link_for_repo(repo, file_path)
        output_dictionary[source_link] = input_dict[element]["learnPath"] \
            .split(".mdx")[0] \
            .lstrip('"') \
            .rstrip('"') \
            .replace(docs_prefix, docs_path_learn)
        source_link = produce_gh_edit_link_for_repo(repo, file_path)
        output_dictionary[source_link] = input_dict[element]["learnPath"] \
            .split(".mdx")[0] \
            .lstrip('"') \
            .rstrip('"') \
            .replace(docs_prefix, docs_path_learn)

        # Check for pages that are category overview pages, and have filepath like ".../monitor/monitor".
        # This way we remove the double dirname in the end, because docusaurus routes the file to .../monitor
        if output_dictionary[source_link].split("/")[len(output_dictionary[source_link].split("/")) - 1] == \
                output_dictionary[source_link].split("/")[len(output_dictionary[source_link].split("/")) - 2]:
            same_parent_dir = output_dictionary[source_link].split(
                "/")[len(output_dictionary[source_link].split("/")) - 2]

            proper_link = output_dictionary[source_link].split(
                same_parent_dir, 1)
            output_dictionary[source_link] = proper_link[0] + \
                                             proper_link[1].strip("/")

        _temp = output_dictionary[source_link].replace("'", " ").replace(":", " ").replace(")", " ").replace(
            ",", " ").replace("(", " ").replace("/  +/g", ' ').replace(" ", "%20").replace('/-+/', '-')
        # If there is a slug present in the file, then that is the new_learn_path, with a "/docs" added in the front.
        try:
            input_dict[element].update(
                {"new_learn_path": "/docs" + input_dict[element]["metadata"]["slug"]})
        except KeyError:
            input_dict[element].update({"new_learn_path": _temp})

    return input_dict


def local_to_absolute_links(path_to_file, input_dict):
    """
    This function is able to recognize and parse relative github links like:

    ../../../../src/database/engine/README.md
    /docs/abc.md
    """

    whole_file = Path(path_to_file).read_text()

    global UNCORRELATED_LINK_COUNTER

    # Determine the repo this file belongs to
    source_repo = extract_repo_from_local_path(path_to_file)

    # Split the file into its metadata and body, so that this function doesn't touch the metadata fields
    # metadata = "---" + whole_file.split("---", 2)[1] + "---"
    body = whole_file

    # custom_edit_url_arr = re.findall(r'custom_edit_url(.*)', metadata)

    # print(input_dict.keys())

    # If there are links inside the body
    if re.search(r"\]\((.*?)\)", body):
        # Find all the links and add them in an array
        urls_with_headers = []
        temp = re.findall(r'\[\n|.*?]\((\n|.*?)\)', body)
        # For every link, store both the base URL and the header
        for link in temp:
            base_url = link.split('#')[0]
            header = link.split('#')[1] if '#' in link else ''
            urls_with_headers.append((base_url, header, link))

        # Deduplicate by full link
        seen = set()
        unique_urls = []
        for base_url, header, full_link in urls_with_headers:
            if full_link not in seen:
                seen.add(full_link)
                unique_urls.append((base_url, header, full_link))

        for url, header, full_link in unique_urls:
            # if not url.startswith("/"):

            if ".md" in url and (any(url in key for key in input_dict.keys())):
                if "http" not in url and url.startswith(".") and len(url) > 0:
                    # print("Link starts with '.'")
                    # The URL will get replaced by the value of the replaceString
                    # try:
                    url_to_replace = url
                    # print(url, path_to_file)

                    path_arr = path_to_file.split('/')

                    url_arr = url.split('/')

                    url_leftover = url_arr.copy()

                    path_arr.pop()
                    for piece in url_arr:
                        if piece == "..":
                            url_leftover.pop(0)
                            path_arr.pop()
                            print(path_arr)

                    replace = "/".join(path_arr) + "/" + "/".join(url_leftover)

                    check = Path(replace)

                    if check.exists():
                        body = body.replace(f"({url_to_replace}", "(" + replace)
                        # Validate header if present
                        if header and not validate_header_in_file(replace, header):
                            add_broken_header(source_repo, full_link, header, path_to_file)
                elif url.startswith("/"):
                    # print("link starting with dash")
                    url_to_replace = url

                    path_arr = path_to_file.split('/')

                    url_arr = url.split('/')

                    # print(path_arr, url_arr)

                    url_leftover = url_arr.copy()

                    replace = f"{path_arr[0]}/{path_arr[1]}" + "/".join(url_leftover)

                    check = Path(replace)

                    if check.exists():
                        body = body.replace(f"({url_to_replace}", "(" + replace)
                        # Validate header if present
                        if header and not validate_header_in_file(replace, header):
                            add_broken_header(source_repo, full_link, header, path_to_file)
            else:
                if (url.startswith(".") or url.startswith("/")):

                    directory = "ingest-temp-folder"
                    substring = url
                    found = False

                    for root, dirs, files in os.walk(directory):
                        for name in files + dirs:
                            if substring in os.path.join(root, name):
                                # print(url, path_to_file, path_to_file.split('/')[1], "NOT IN LEARN")

                                replace = f"(https://github.com/netdata/{path_to_file.split('/')[1]}/blob/master{url}"

                                body = body.replace(f"({url}", replace)
                                found = True
                                break
                        if found:
                            break
                    
                    if not found:
                        UNCORRELATED_LINK_COUNTER += 1
                        add_broken_url(source_repo, url, path_to_file)


    Path(path_to_file).write_text(body)


def convert_github_links(path_to_file, input_dict):
    """
    Input:
        path: The path to the markdown file
        input_dict: the dictionary with every info about all files

    Expected format of links in files:
        [*](https://github.com/netdata/netdata/blob/master/*)
        or any other Netdata repo
    """

    whole_file = Path(path_to_file).read_text()

    global UNCORRELATED_LINK_COUNTER

    # Split the file into its metadata and body, so that this function doesn't touch the metadata fields
    metadata = "---" + whole_file.split("---", 2)[1] + "---"
    body = whole_file.split("---", 2)[2]

    custom_edit_url_arr = re.findall(r'custom_edit_url(.*)', metadata)
    
    # Determine the source repo from the custom_edit_url in metadata
    # This tells us which repo the current file originally came from
    source_repo = "unknown"
    if custom_edit_url_arr and len(custom_edit_url_arr[0]) > 1:
        custom_edit_url = custom_edit_url_arr[0].replace("\"", "").strip(": ")
        source_repo = extract_repo_from_github_url(custom_edit_url)

    # If there are links inside the body
    if re.search(r"\]\((.*?)\)", body):
        # Find all the links and add them in an array
        urls_with_headers = []
        temp = re.findall(r'\[\n|.*?]\((\n|.*?)\)', body)
        # For every link, store both the base URL and the header
        for link in temp:
            base_url = link.split('#')[0]
            header = link.split('#')[1] if '#' in link else ''
            urls_with_headers.append((base_url, header, link))

        for url, header, full_link in urls_with_headers:
            # The URL will get replaced by the value of the replaceString
            try:
                # The keys inside fileDict are like "ingest-temp-folder/netdata/collectors/charts.d.plugin/ap/README.md"
                # so from the link, we need:
                # 1. replace the https link prefix up until our organization identifier with the prefix of the temp folder
                # 2. try and catch any mishaps in links that instead of "blob" have "edit"
                # 3. remove "blob/master/" or "blob/main/"
                # 4. Then we have the correct key for the dictionary

                dict_key = url.replace("https://github.com/netdata", TEMP_FOLDER).replace(
                    "edit/", "blob/", 1).replace("blob/master/", "").replace("blob/main/", "")
                dictionary = input_dict[dict_key]

                replace_string = dictionary["new_learn_path"].replace("//", "/")

                # In some cases, a "id: someId" will be in a file, this is to change a file's link in Docusaurus,
                # so we need to be careful to honor that
                try:
                    metadata_id = dictionary["metadata"]["id"]

                    replace_string = replace_string.replace(
                        replace_string.split(
                            "/")[len(replace_string.split("/")) - 1],
                        metadata_id
                    )

                except Exception as e:
                    # There is no "id" metadata in the file, do nothing

                    pass

                body = body.replace("](" + url, "](" + replace_string)
                
                # Validate header if present - check against the source file in temp folder
                if header and dict_key in input_dict:
                    source_file = dict_key
                    if Path(source_file).exists() and not validate_header_in_file(source_file, header):
                        # Use source_repo (where the file with the broken link is from)
                        add_broken_header(source_repo, full_link, header, path_to_file)
                        
                # In the end replace the URL with the replaceString
            except Exception as e:
                # This is probably a link that can't be translated to a Learn link (e.g. An external file)
                if url.startswith("https://github.com/netdata") and re.search(r"\.md", url):
                    # Try to rescue an integration link
                    if "integrations" in url and ("collector" in url):
                        # Due to the integrations/cloud_notifications/integrations/.. scenario, we use rsplit to remove the last occurrence of "integrations"
                        # We want to map links to specific integrations mds, to their parent README, in case the above try-catch failed to find the replacement.
                        try_url = url.rsplit("integrations", 1)[
                                      0] + "README.md"
                        # The URL will get replaced by the value of the replaceString
                        try:
                            # The keys inside fileDict are like "ingest-temp-folder/netdata/collectors/charts.d.plugin/ap/README.md"
                            # , so from the link, we need:
                            # replace the https link prefix until our organization identifier with the prefix of the temp folder
                            # try and catch any mishaps in links that instead of "blob" have "edit"
                            # remove "blob/master/" or "blob/main/"
                            # Then we have the correct key for the dictionary

                            dict_key = try_url.replace("https://github.com/netdata", TEMP_FOLDER).replace(
                                "edit", "blob").replace("blob/master/", "").replace("blob/main/", "")
                            dictionary = input_dict[dict_key]
                            replace_string = dictionary["new_learn_path"]

                            # In some cases, a "id: someId" will be in a file, this is to change a file's link in Docusaurus,
                            # so we need to be careful to honor that
                            try:
                                metadata_id = dictionary["metadata"]["id"]

                                replace_string = replace_string.replace(
                                    replace_string.split(
                                        "/")[len(replace_string.split("/")) - 1],
                                    metadata_id
                                )
                            except Exception as e:
                                # There is no "id" metadata in the file, do nothing
                                pass

                            # In the end replace the URL with the replaceString
                            body = body.replace("](" + url, "](" + replace_string)
                            
                            # Validate header if present
                            if header and Path(dict_key).exists() and not validate_header_in_file(dict_key, header):
                                add_broken_header(source_repo, full_link, header, path_to_file)
                        except:
                            # Only mark as broken if the file doesn't exist in the repos
                            # Files that exist but aren't published to Learn are fine - they stay as GitHub links
                            if not file_exists_in_repos(url):
                                UNCORRELATED_LINK_COUNTER += 1
                                add_broken_url(source_repo, url, path_to_file)

                            if len(custom_edit_url_arr[0]) > 1:
                                custom_edit_url = custom_edit_url_arr[0].replace(
                                    "\"", "").strip(":")
                            else:
                                custom_edit_url = "NO custom_edit_url found, please add one"

                            # print(UNCORRELATED_LINK_COUNTER,
                            #       "INFO: In File:",
                            #       custom_edit_url,
                            #       "\n", "URL:", url, "\n")
                    else:
                        # Only mark as broken if the file doesn't exist in the repos
                        # Files that exist but aren't published to Learn are fine - they stay as GitHub links
                        if not file_exists_in_repos(url):
                            UNCORRELATED_LINK_COUNTER += 1
                            add_broken_url(source_repo, url, path_to_file)

                        if len(custom_edit_url_arr[0]) > 1:
                            custom_edit_url = custom_edit_url_arr[0].replace(
                                "\"", "").strip(":")
                        else:
                            custom_edit_url = "NO custom_edit_url found, please add one"

                        # print(UNCORRELATED_LINK_COUNTER,
                        #       "INFO: In File:",
                        #       custom_edit_url,
                        #       "\n", "URL:", url, "\n")

    # Construct again the whole file
    whole_file = metadata + body

    # Write everything onto the file again
    Path(path_to_file).write_text(whole_file)


def automate_sidebar_position(dictionary):
    """
    Dynamically assigns position numbers to each file entry based on its depth in the directory.
    More room is provided between categories to accommodate up to 500 files per level.

    Levels:
    - Level 1: 100,000 gap between categories
    - Level 2: 2,000 gap between subcategories (allows room for 500+ files per category)
    - Level 3: 500 gap between sub-subcategories
    - Level 4: Serial numbering within Level 3 (increments by 10 for documents)
    """

    print("### Automating sidebar_position ###", '\n')

    position_array = []

    # Initial counters for each level
    counter_one = 100_000
    serial_two = 0  # Serial counter for level 2
    serial_three = 0  # Serial counter for level 3
    serial_four = 0  # Serial counter for level 4

    previous_levels = ["", "", ""]

    for path in dictionary['learn_rel_path']:
        if str(path) != "nan":
            split = str(path).split("/")

            # Ensure there are at least 3 levels (for category and subcategories)
            current_levels = split + [""] * (3 - len(split))

            # Update counters based on level changes
            if current_levels[0] != previous_levels[0]:
                # New Level 1 category, reset counters
                counter_one += 100_000
                serial_two = 0
                serial_three = 0
                serial_four = 0
            elif current_levels[1] != previous_levels[1]:
                # New Level 2 category, increment serial for Level 2
                serial_two += 2_000  # Allow 2,000 gap for each subcategory
                serial_three = 0  # Reset serial for Level 3
                serial_four = 0  # Reset serial for Level 4
            elif current_levels[2] != previous_levels[2]:
                # New Level 3 category, increment serial for Level 3
                serial_three += 500  # Allow 500 gap for files within each subcategory
                serial_four = 0  # Reset serial for Level 4
            else:
                # Increment serial for Level 4
                serial_four += 10  # Serial for documents within Level 3

            previous_levels = current_levels

            # Calculate the final position based on the counters
            position_value = counter_one + serial_two + serial_three + serial_four

            # Append the calculated position
            position_array.append(position_value)
        else:
            # If the path is nan, return -1
            position_array.append(-1)

    return position_array


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Ingest docs from multiple repositories')

    parser.add_argument(
        '--repos',
        default=[],
        nargs='+',
        help='Choose specific repo you want ingest, if not set, defaults ingested'
    )

    parser.add_argument(
        "--dry-run",
        help="Don't save a file with the output.",
        action="store_true",
    )

    parser.add_argument(
        "-d", "--debug",
        help="Enable debug printing",
        action="store_true",
    )

    parser.add_argument(
        "--docs-prefix",
        help="Don't save a file with the output.",
        dest="DOCS_PREFIX",
        default="docs"
    )

    parser.add_argument(
        "--fail-ingest-workflow",
        help="Exit with error code 1 at the end if any internal broken links are found (any repo).",
        action="store_true",
    )

    parser.add_argument(
        "--fail-on-netdata",
        help="Exit with error code 1 if broken links are found in the netdata repo.",
        action="store_true",
    )

    parser.add_argument(
        "--fail-on-helmchart",
        help="Exit with error code 1 if broken links are found in the helmchart repo.",
        action="store_true",
    )

    parser.add_argument(
        "--fail-on-cloud-onprem",
        help="Exit with error code 1 if broken links are found in the netdata-cloud-onprem repo.",
        action="store_true",
    )

    parser.add_argument(
        "--fail-on-agent-service-discovery",
        help="Exit with error code 1 if broken links are found in the agent-service-discovery repo.",
        action="store_true",
    )

    parser.add_argument(
        "--fail-on-grafana-plugin",
        help="Exit with error code 1 if broken links are found in the netdata-grafana-datasource-plugin repo.",
        action="store_true",
    )

    parser.add_argument(
        "--fail-on-github-repo",
        help="Exit with error code 1 if broken links are found in the .github repo.",
        action="store_true",
    )

    parser.add_argument(
        "--gh-token",
        help="GitHub Personal Access Token for HTTPS cloning (optional, used only for local testing).",
        dest="gh_token",
        default=None,
    )

    list_of_repos_in_str = []
    # netdata/netdata:branch tkatsoulas/go.d.plugin:mybranch
    args = parser.parse_args()
    kArgs = args._get_kwargs()
    GITHUB_TOKEN = args.gh_token

    # Create local copies from the parse_args input
    DOCS_PREFIX = args.DOCS_PREFIX
    for arg in kArgs:
        if arg[0] == "repos":
            list_of_repos_in_str = arg[1]
        if arg[0] == "dry_run":
            DRY_RUN = arg[1]
        if arg[0] == "debug" or arg[0] == "debug":
            if arg[1]:
                DEBUG = True
                print("RUNNING WITH DEBUG MESSAGES ON")
        if arg[0] == "fail_ingest_workflow":
            FAIL_ON_ALL_BROKEN_LINKS = arg[1]
        if arg[0] == "fail_on_netdata":
            if arg[1]:
                FAIL_ON_REPOS.add("netdata")
        if arg[0] == "fail_on_helmchart":
            if arg[1]:
                FAIL_ON_REPOS.add("helmchart")
        if arg[0] == "fail_on_cloud_onprem":
            if arg[1]:
                FAIL_ON_REPOS.add("netdata-cloud-onprem")
        if arg[0] == "fail_on_agent_service_discovery":
            if arg[1]:
                FAIL_ON_REPOS.add("agent-service-discovery")
        if arg[0] == "fail_on_grafana_plugin":
            if arg[1]:
                FAIL_ON_REPOS.add("netdata-grafana-datasource-plugin")
        if arg[0] == "fail_on_github_repo":
            if arg[1]:
                FAIL_ON_REPOS.add(".github")

    if len(list_of_repos_in_str) > 0:
        for repo_str in list_of_repos_in_str:
            try:
                _temp = repo_str.split("/")
                repo_owner, repository, repo_branch = [
                                                          _temp[0]] + (_temp[1].split(":"))
                default_repos[repository]["owner"] = repo_owner
                default_repos[repository]["branch"] = repo_branch
            except (TypeError, ValueError):
                print(
                    "You specified a wrong format in at least one of the repos you want to ingest")
                parser.print_usage()
                exit(-1)
            except KeyError:
                print(repository)
                print("The repo you specified in not in predefined repos")
                print(default_repos.keys())
                parser.print_usage()
                exit(-1)
            except Exception as exc:
                print("Unknown error in parsing", exc)

    # Clean up old clones into a temp dir
    unsafe_cleanup_folders(TEMP_FOLDER)
    # Clean up old ingested docs
    safe_cleanup_learn_folders(DOCS_PREFIX)
    print("Creating a temp directory: ", TEMP_FOLDER)

    try:
        os.mkdir(TEMP_FOLDER)
    except FileExistsError:
        print("Folder already exists")

    # Clone all the predefined repos
    for repo_name in default_repos.keys():
        print(clone_repo(
            default_repos[repo_name]["owner"],
            repo_name,
            default_repos[repo_name]["branch"],
            1,
            TEMP_FOLDER + "/",
            GITHUB_TOKEN,
        ))

    shutil.move("ingest-temp-folder/netdata/docs/.map/map.csv", "map.csv")

    # We fetch the markdown files from the repositories
    all_markdown_files = fetch_markdown_from_repo(TEMP_FOLDER)
    print("Files detected: ", len(all_markdown_files), "\n")

    # Fill the mapDict with the metadata the integration mds have (autogenerated metadata)
    mapDict = populate_integrations(all_markdown_files)

    # set the index to the unique custom_edit_url column
    mapDict.set_index('custom_edit_url').T.to_dict('dict')

    # Automate the sidebar position
    mapDict['sidebar_position'] = automate_sidebar_position(mapDict)
    # Make the column type integer
    mapDict['sidebar_position'] = mapDict['sidebar_position'].astype(int)

    markdown_files_with_metadata = []

    for markdown in all_markdown_files:
        # print("File: ", markdown)
        md_metadata = insert_and_read_hidden_metadata_from_doc(
            markdown, mapDict)
        # Check to see if the dictionary returned is empty
        if len(md_metadata) > 0:
            # print("FOUND METADATA", markdown)
            # print(metadata)
            markdown_files_with_metadata.append(markdown)
            if "learn_status" in md_metadata.keys() and md_metadata["learn_status"] == "Published":
                try:
                    # check the type of the response (for more info of what the response can be check
                    # the return statements of the function itself)
                    response = create_mdx_path_from_metadata(md_metadata)
                    sanitize_regex = r'`|\(|\)'
                    if type(response) != str:
                        # If the response is not a string then it is a two item array, [final path, slug]
                        md_metadata.update({"slug": str(response[1])})
                        to_publish[markdown] = {
                            "metadata": md_metadata,
                            "learnPath": str(response[0]),
                            "ingestedRepo": str(markdown.split("/", 2)[1])
                        }

                        # Fix duplicate last segment in learn_link for overview pages
                        slug = md_metadata['slug']
                        slug_parts = slug.strip('/').split('/')
                        if len(slug_parts) >= 2 and slug_parts[-1] == slug_parts[-2]:
                            # Remove duplicate last segment
                            fixed_slug = '/' + '/'.join(slug_parts[:-1])
                            fixed_slug = convert_parenthetical_slash(fixed_slug)
                            fixed_slug = re.sub(sanitize_regex, '', fixed_slug)
                            md_metadata.update({"learn_link": "https://learn.netdata.cloud/docs" + fixed_slug})
                        else:
                            slug = convert_parenthetical_slash(slug)
                            slug = re.sub(sanitize_regex, '', slug)
                            md_metadata.update({"learn_link": "https://learn.netdata.cloud/docs" + slug})

                    else:
                        to_publish[markdown] = {
                            "metadata": md_metadata,
                            "learnPath": str(response),
                            "ingestedRepo": str(markdown.split("/", 2)[1])
                        }
                        clean_sidebar = clean_and_lower_string(md_metadata['sidebar_label'])
                        rel_path = clean_and_lower_string(md_metadata['learn_rel_path'])
                        if rel_path != clean_sidebar:
                            # Compose the canonical link and remove only a single duplicated final segment if present.
                            link = "https://learn.netdata.cloud/docs/" + rel_path + "/" + clean_sidebar
                            link_parts = link.rstrip('/').split('/')
                            if len(link_parts) >= 2 and link_parts[-1] == link_parts[-2]:
                                link = '/'.join(link_parts[:-1])
                            link = convert_parenthetical_slash(link)
                            link = re.sub(sanitize_regex, '', link)
                            md_metadata.update({"learn_link": link})
                        else:
                            link = "https://learn.netdata.cloud/docs/" + rel_path
                            link_parts = link.rstrip('/').split('/')
                            if len(link_parts) >= 2 and link_parts[-1] == link_parts[-2]:
                                link = '/'.join(link_parts[:-1])
                            link = convert_parenthetical_slash(link)
                            link = re.sub(sanitize_regex, '', link)
                            md_metadata.update({"learn_link": link})
                    update_metadata_of_file(markdown, md_metadata)
                except KeyError as exc:
                    print(
                        f"File {markdown} doesn't contain key-value", exc)
            else:
                # We don't need these files
                rest_files_with_metadata_dictionary[markdown] = {
                    "metadata": md_metadata,
                    "learnPath": str(f"docs/_archive/_{markdown}"),
                    "ingestedRepo": str(markdown.split("/", 2)[1])
                }
        # Don't fail on empty markdown
        elif not os.stat(markdown).st_size == 0:
            rest_files_dictionary[markdown] = {"tmpPath": markdown}
        del md_metadata

    # FILE MOVING
    print("### Moving files ###\n")

    # identify published documents
    print(f"### Found Learn files: {len(to_publish)}###\n")

    for md_file in to_publish:
        local_to_absolute_links(md_file, to_publish)
        copy_doc(md_file, to_publish[md_file]["learnPath"])
        sanitize_page(to_publish[md_file]["learnPath"])

    print("### Fixing github links ###")

    # After the moving, we have a new metadata, called new_learn_path, and we utilize that to fix links that were
    # pointing to GitHub relative paths
    file_dict = add_new_learn_path_key_to_dict(
        to_publish, DOCS_PREFIX, "/docs", TEMP_FOLDER)

    for md_file in to_publish:
        convert_github_links(file_dict[md_file]["learnPath"], file_dict)

    genRedirects.main(file_dict)
    print("Done.", "Uncorrelated links (links from our github repos that the files are not in Learn):",
          UNCORRELATED_LINK_COUNTER)

    # Print deduplicated list of uncorrelated URLs grouped by repo
    total_broken_urls = sum(len(urls) for urls in UNCORRELATED_URLS_BY_REPO.values())
    repos_with_broken_urls = set()
    if total_broken_urls > 0:
        print("\n### Uncorrelated URLs (grouped by repo) ###")
        for repo in sorted(UNCORRELATED_URLS_BY_REPO.keys()):
            repo_urls = UNCORRELATED_URLS_BY_REPO[repo]
            if len(repo_urls) > 0:
                repos_with_broken_urls.add(repo)
                print(f"\n=== Repo: {repo} ({len(repo_urls)} broken URLs) ===")
                for url in sorted(repo_urls.keys()):
                    print(f"\n  Broken link: {url}")
                    print(f"  Referenced in {len(repo_urls[url])} file(s):")
                    for source_file in sorted(repo_urls[url]):
                        print(f"    - {source_file}")
        print(f"\nTotal unique broken URLs: {total_broken_urls}")

    # Print broken header links grouped by repo
    total_broken_headers = sum(len(headers) for headers in BROKEN_HEADER_LINKS_BY_REPO.values())
    repos_with_broken_headers = set()
    if total_broken_headers > 0:
        print("\n### Broken Header/Anchor Links (grouped by repo) ###")
        for repo in sorted(BROKEN_HEADER_LINKS_BY_REPO.keys()):
            repo_headers = BROKEN_HEADER_LINKS_BY_REPO[repo]
            if len(repo_headers) > 0:
                repos_with_broken_headers.add(repo)
                print(f"\n=== Repo: {repo} ({len(repo_headers)} broken header links) ===")
                for (full_link, header) in sorted(repo_headers.keys()):
                    print(f"\n  Broken link: {full_link}")
                    print(f"  Missing header: #{header}")
                    print(f"  Referenced in {len(repo_headers[(full_link, header)])} file(s):")
                    for source_file in sorted(repo_headers[(full_link, header)]):
                        print(f"    - {source_file}")
        print(f"\nTotal unique broken header links: {total_broken_headers}")

    # Combine all repos with any broken links
    all_repos_with_issues = repos_with_broken_urls | repos_with_broken_headers
    
    # Determine if we should fail based on flags
    should_fail = False
    failed_repos = []
    
    # Check if --fail-on-internal-broken-links is set (fail on any broken link)
    if FAIL_ON_ALL_BROKEN_LINKS and len(all_repos_with_issues) > 0:
        should_fail = True
        failed_repos = list(all_repos_with_issues)
    
    # Check per-repo failure flags
    for repo in FAIL_ON_REPOS:
        if repo in all_repos_with_issues:
            should_fail = True
            if repo not in failed_repos:
                failed_repos.append(repo)
    
    # Store failure state but continue processing
    SHOULD_EXIT_WITH_FAILURE = False
    if should_fail:
        SHOULD_EXIT_WITH_FAILURE = True
        print(f"\n### BROKEN LINKS DETECTED in repos: {', '.join(sorted(failed_repos))} ###")
        print("Will exit with error code 1 at the end due to flags:")
        if FAIL_ON_ALL_BROKEN_LINKS:
            print("  --fail-ingest-workflow (fail on any broken link)")
        for repo in sorted(failed_repos):
            if repo in FAIL_ON_REPOS:
                print(f"  --fail-on-{repo.replace('_', '-')}")
        print("\nContinuing with remaining ingest steps...")

    if DEBUG:
        # Print the list of markdown not in Learn, for debugging purposes
        if len(rest_files_dictionary):
            print("ABORT: Files found that are not in the map, exiting...")
            for md_file in rest_files_dictionary:
                print(rest_files_dictionary[md_file]["tmpPath"])

    # Write the current dict into a file, so we can check for redirects in the next commit
    temp_dict = {}
    custom_edit_urls_array = []
    new_learn_paths_array = []

    for repo_name in file_dict:
        custom_edit_urls_array.append(
            file_dict[repo_name]["metadata"]["custom_edit_url"])
        new_learn_paths_array.append(file_dict[repo_name]["new_learn_path"])

    temp_dict['custom_edit_url'] = custom_edit_urls_array
    temp_dict['learn_path'] = new_learn_paths_array

    df = pd.DataFrame.from_dict(temp_dict)
    df.set_index('custom_edit_url')
    df.to_csv("./ingest/one_commit_back_file-dict.tsv", sep='\t', index=False)

    unsafe_cleanup_folders(TEMP_FOLDER)
    os.remove("map.csv")
    print("OPERATION FINISHED, map deleted")


    def sort_files(file_array):
        most_popular = []
        rest_netdata_integrations = []
        community_integrations = []

        for file in file_array:
            if Path(file).is_file():
                # [filename, filepath, banner message, banner color]
                content = Path(file).read_text()

                if "most_popular: \"True\"" in content:
                    most_popular.append(
                        [str(file).lower().rsplit("/", 1)[1], file, "by Netdata", "#00ab44"])
                elif "maintained%20by-Netdata-" in content:
                    rest_netdata_integrations.append(
                        [str(file).lower().rsplit("/", 1)[1], file, "by Netdata", "#00ab44"])
                else:
                    community_integrations.append(
                        [str(file).lower().rsplit("/", 1)[1], file, "by Community", "rgba(0, 0, 0, 0.25)"])

        sorted_array = sorted(
            most_popular) + sorted(rest_netdata_integrations) + sorted(community_integrations)

        return sorted_array


    def get_dir_make_file_and_recurse(directory):
        dir_path, dir_name = str(directory).rsplit("/", 1)
        filename = f"{dir_path}/{dir_name}/{dir_name}.mdx"

        # Check if the directory contains only one file and that file matches the directory name
        direct_files = list(Path(directory).glob("*.mdx"))
        if len(direct_files) == 1 and direct_files[0].stem == dir_name:
            # Skip generating a grid page for single integration leaf files
            return

        # Do stuff for all the files inside the dict, auth folder currently has only one file
        if len(sorted(Path(directory).glob(
                "**/**/*"))) > 1 or directory == "docs/netdata-cloud/authentication-&-authorization/cloud-authentication-&-authorization-integrations":
            sorted_list = sort_files(Path(directory).glob("**/**/*"))

            try:
                sidebar_position = re.search(
                    r'sidebar_position:.*', Path(sorted_list[0][1]).read_text(encoding='utf-8'))[0]
            except TypeError:
                sidebar_position = ""

            sidebar_label = str(directory).rsplit("/", 1)[1]

            if "cloud-authentication-&-authorization-integrations" in sidebar_label:
                sidebar_label = "Cloud Authentication & Authorization Integrations"
            if "collecting-metrics" in str(directory):
                sidebar_position = ""

            if "centralized-cloud-notifications" in sidebar_label:
                sidebar_label = "Centralized Cloud Notifications"
            elif "agent-dispatched-notifications" in sidebar_label:
                sidebar_label = "Agent Dispatched Notifications"
            elif sidebar_label == "alerts-&-notifications":
                sidebar_label = "Alerts & Notifications"
            elif sidebar_label == "connectors":
                sidebar_label = "Connectors"
            elif "logs" in sidebar_label:
                sidebar_label = "Logs"

            md = \
                f"""---
sidebar_label: "{sidebar_label}"
{sidebar_position}
hide_table_of_contents: true
learn_status: "AUTOGENERATED"
slug: "{clean_and_lower_string(str(directory)).split('docs', 1)[1]}"
learn_link: "https://learn.netdata.cloud/{clean_and_lower_string(str(directory))}"
---

# {sidebar_label}

import \u007b Grid, Box \u007d from '@site/src/components/Grid_integrations';

<Grid  columns="4">
"""

            integrations = 0

            for file_array_entry in sorted_list:
                file = file_array_entry[1]
                message = file_array_entry[2]
                color = file_array_entry[3]
                if Path(file).is_file():
                    whole_file = Path(file).read_text(encoding='utf-8')

                    is_only_integration = sum(1 for f in Path(str(file_array_entry[1]).rsplit("/", 1)[0]).iterdir(
                    ) if f.is_file() and "DO NOT EDIT THIS FILE DIRECTLY" in f.read_text(errors='ignore')) <= 1

                    is_only_file = sum(1 for f in Path(str(file_array_entry[1]).rsplit(
                        "/", 1)[0]).iterdir() if f.is_file()) <= 1

                    direct_child = file.parent == Path(directory)

                    if "DO NOT EDIT THIS FILE DIRECTLY" in whole_file:

                        meta_dict = read_metadata(whole_file)

                        # if it is the only integration, and the direct child is a published/custom integration
                        # (e.g. a proper content file), then we don't want to create/replace a grid page for this dir.
                        if direct_child and is_only_integration:
                            # prefer explicit publish flag or presence of custom_edit_url to determine a content page
                            if meta_dict.get("learn_status") == "Published" or "custom_edit_url" in meta_dict:
                                return

                        # if the structure is like A/B/B.mdx but B/ has more files in it (Logs integrations mainly) then truncate the B.mdx from B/B.mdx as it is a folder now.
                        if meta_dict["learn_link"].split("/")[-1] == meta_dict["learn_link"].split("/")[
                            -2] and not is_only_file:
                            meta_dict["learn_link"] = meta_dict["learn_link"].rsplit(
                                "/", 1)[0]
                            print("IN", type(meta_dict["learn_link"]), file_array_entry, directory, direct_child
                                  )

                        try:
                            img = re.search(r'<img src="https:\/\/netdata.cloud\/img.*', whole_file)[0].replace(
                                "width=\"150\"",
                                "style={{width: '90%', maxHeight: '100%', verticalAlign: 'middle' }}").replace("<img",
                                                                                                               "<img custom-image")
                        except TypeError:
                            img = ""

                        md += \
                            f"""
<Box banner="{message}" banner_color="{color}" to="{meta_dict["learn_link"].replace("https://learn.netdata.cloud", "")}"  title="{meta_dict["sidebar_label"]}">
    {img}
</Box>
"""
                        integrations += 1

            if integrations < 1:
                return

            md += "\n</Grid>"
            Path(filename.rsplit("/", 1)[0]).mkdir(parents=True, exist_ok=True)
            Path(filename).write_text(md, encoding='utf-8')

            for subdir in sorted(Path(directory).glob("*/")):
                get_dir_make_file_and_recurse(subdir)


    for path in Path('docs/collecting-metrics').glob('*/'):
        get_dir_make_file_and_recurse(path)

    get_dir_make_file_and_recurse(
        'docs/alerts-&-notifications/notifications/agent-dispatched-notifications')
    get_dir_make_file_and_recurse(
        'docs/alerts-&-notifications/notifications/centralized-cloud-notifications')
    get_dir_make_file_and_recurse('docs/exporting-metrics/connectors')
    get_dir_make_file_and_recurse(
        'docs/netdata-cloud/authentication-&-authorization/cloud-authentication-&-authorization-integrations')
    get_dir_make_file_and_recurse(
        'docs/logs')

    # Exit with failure if broken links were detected and failure flag was set
    if SHOULD_EXIT_WITH_FAILURE:
        print("\n### FAILURE: Exiting with error code 1 due to broken links ###")
        exit(1)
